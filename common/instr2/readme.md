# Исключения и обработка ошибок

В этом лонгриде:
- Разберёмся, какие бывают ошибки
- Познакомимся с методами поиска, предотвращения и обработки ошибок
- Узнаем, что такое коды возврата
- Выясним, что такое исключения

План:
1. Ошибки и поиск ошибок
2. Коды возврата
3. Исключения

# Ошибки и поиск ошибок
Ошибки можно разделить на 2 группы:
1. Ошибки времени компиляции
2. Ошибки времени выполнения

### Ошибки времени компиляции
Это синтаксические ошибки, которые препятствуют сборке программы. Мы не раз с ними сталкивались — например, если забыли где-то поставить `;` (точку с запятой) в конце строки или `{ }` (открывающую/закрывающую) скобку. Синтаксические ошибки легко найти — программа не сможет собраться, а компилятор укажет, в чём ошибка.

### Ошибки времени выполнения
Возникают в ходе работы программы. Например, если вы пытаетесь поделить на ноль, обратиться к элементу массива по индексу, выходящему за его пределы, открыть несуществующий файл, выделить памяти больше, чем её доступно. При таких ошибках программа сама завершится из-за невозможности продолжать свою работу.

Бывают и другие ошибки — они связаны с тем, как должна работать программа по задумке программиста. Например, в программе «Калькулятор» вы можете вместо перемножения чисел складывать их — программа от этого не сломается, но результат будет не тот, что задумывался изначально. Такие ошибки отловить сложнее всего — для этого существует тестирование. В этой статье мы не будем рассматривать подобные ошибки.

## Способы поиска ошибок

### Рассмотрим пример
Представим, что мы запускаем написанную нами программу «Калькулятор», а она в какой-то момент прекращает работу.

Чтобы найти ошибку, нам нужно проследить, как работает наш код. Для этого мы можем:
- войти в режим отладки и последовательно её выполнить
- заставить программу сообщать нам о том, на каком этапе выполнения она находится — это называется логирование

Отладка — это процесс обнаружения, анализа и исправления ошибок в программном коде. Отладчики позволяют шаг за шагом выполнять код, просматривать и изменять значения переменных, останавливать выполнение программы при определённых условиях и таким образом локализовать и устранить проблемы. 

Логирование — это процесс записи информации о работе программы или системы в файлы журналов (лог-файлы). Эти записи могут включать данные о событиях, которые произошли во время выполнения программы, сообщения об ошибках, информацию о транзакциях, статистику работы и другие данные, которые могут быть полезны при анализе и отладке программ. Логирование помогает разработчикам понять, что произошло в приложении после его запуска, и часто является ключевым элементом для выявления и устранения проблем, а также для мониторинга состояния системы в реальном времени.

### Преимущества и недостатки отладки

Плюсы:
- не нужно изменять исходный код
- наглядно, можно посмотреть состояние любой переменной, какая функция вызывает другую функцию, видеть стек вызовов

Минусы:
- требует доступа к исходному коду
- требует наличия отладчика и возможности его запуска

  
Что касается запуска отладчика, не всегда это возможно.
Например, десктопный Яндекс браузер работает на Windows 7 в том числе. А большинство разработчиков пользуются современными быстрыми ОС. И, когда случается специфичный баг на Windows 7, его нужно как-то отладить. Для этих целей используется старый ноутбук со специально установленной Windows 7. Но на нём трудно скомпилировать, запустить браузер и пользоваться отладкой. Приходится с современной машины подключаться к старому ноутбуку, выполнять действия на Windows 7, а отлаживать браузер на новой ОС.


- если программа большая, то поиск может затянуться 

Отладка подходит для поиска ошибок в процессе разработки программы.

### Преимущества и недостатки логирования

Плюсы:
- не требуется доступа к исходному коду, работает вместе с программой
- все этапы выполнения программы доступны сразу, их надо только проанализировать

Минусы:
- логирование требует дополнительного кода в программе


Чтобы в программе были логи, нужно понять, где их написать. Вы не сможете это сделать на любую возможную проблему. Если будет слишком много логов, программа начнёт тормозить, или у пользователя внезапно закончится свободное место на диске.

- при маленьких объёмах кода время, потраченное на логирование, может быть больше, чем вся возможная отладка

Логирование используется, когда программа уже готова, и начинают приходить ошибки от пользователей.

## Что делать с найденной ошибкой

Предположим, мы обнаружили, что наша программа «Калькулятор» падает, если мы пытаемся вторым аргументом в функцию `divide` передать число 0.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/c09f1d29-b150-4025-8f6b-648890d06b88)

Как исправить такой код?

Способ 1. Можем попробовать сделать проверку в функции divide перед выполнением операции деления:

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/41f256ae-6dda-432a-81bf-403bd9f0b105)

Добавим `if (b == 0)`, нам нужно что-то вернуть в `return`. Если напишем какое-то число, это будет работать, но мы не сможем отличить ошибочный результат от реального.

Например, напишем: `return 1`. В случае, если `int a = 10`, а `int b = 10`, и реальный и ошибочный результат будут одинаковыми.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/3c05b176-251d-486e-8bd0-0db14ae55ff3)

Способ 2. Можем попробовать сделать проверку в функции main перед вызовом функции divide

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/15d0fe9f-298a-4b22-b16e-d306bcef11aa)

Так программа будет работать. Но это плохое решение. Получается, что внешний код должен заботиться о том, как работает функция: какие параметры можно передавать, а какие нельзя. Логика получается размазанной: часть логики во внешнем коде, часть внутри функции. 

К тому же, если функция main будет проверять аргументы всех вызываемых ею функций, то код функции main станет очень большим и несфокусированным. Это нарушает принцип инкапсуляции.

Таким образом, оба рассмотренных способа не подходят для решения проблемы. 

Её возможно решить следующими действиями:
- вернуть код возврата, то есть, вместо результата будем возвращать некий код
- выбросить исключения

## Коды возврата

Коды возврата — это способ сообщения о произошедшей ошибке, который использовался ещё в языке C. Идея в том, что функция вместо результата, который она должна посчитать, возвращает специальный код, который сообщает о том, правильно отработала функция или нет. Обычно в качестве кодов возврата используются целые числа.

Допустим, мы вернём код возврата. Но как тогда получить результат функции?

Для того, чтобы вернуть результат, в функцию передаётся ещё один аргумент — указатель на переменную, в которую будет помещён результат функции. Вместо указателя может выступать переменная, переданная по ссылке.

Обычно делают так: код 0 (ноль) означает, что функция отработала корректно. Коды больше 0 означают ошибку. 

Давайте вернём код 1, если знаменатель равен 0 и функция не может произвести деление. В функции main обработаем код возврата — если он не 0, то функция отработала некорректно. Сообщим об этом пользователю.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/a8e0a98c-0ac9-4a33-b696-de3b40e72357)

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/4af0cb49-63aa-47de-90d5-452ad27da5e3)


Если мы поменяем знаменатель на положительное число, например, int b = 5, получим результат деления:

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/4f6f5ecc-1fa9-4411-8164-a8330f52275d)

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/c31e4a2b-33d4-4ce6-943a-9df1f1d78856)

Теперь, когда мы изменили нашу функцию divide, появилось новое место для потенциальной ошибки. Нам могут в качестве аргумента quotient прислать нулевой указатель (nullptr). Это указатель, который не указывает ни на какой участок памяти. Адрес, хранящийся в нём, равен нулю. Если мы попытаемся записать значение по такому указателю, мы получим ошибку и наша программа аварийно завершится. 

Давайте добавим ещё одну проверку: если указатель нулевой, вернём код 2, а в функции main выведем сообщение пользователю.


![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/d7578262-fee6-41e9-8696-df734bae4e85)


![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/17af20a8-4f57-41f3-8bd5-d350cdaed0df)

Рассмотрим, почему в данном случае лучше использовать указатель, а не ссылку.
- У вас может быть какой-то объект очень тяжёлый, большой класс. 
- В C++ не все типы можно сконструировать. Например, если у класса нет конструктора по умолчанию.

А вам нужно сделать запись в этот класс
