# Исключения и обработка ошибок

В этом лонгриде:
- Разберёмся, какие бывают ошибки
- Познакомимся с методами поиска, предотвращения и обработки ошибок
- Узнаем, что такое коды возврата
- Выясним, что такое исключения

План:

1. [Ошибки и поиск ошибок](https://github.com/netology-code/cppm-homeworks/blob/main/common/instr2/readme.md#%D0%BE%D1%88%D0%B8%D0%B1%D0%BA%D0%B8-%D0%B8-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)

2. [Коды возврата](https://github.com/netology-code/cppm-homeworks/blob/main/common/instr2/readme.md#2-%D0%BA%D0%BE%D0%B4%D1%8B-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82%D0%B0)
   
3. [Исключения](https://github.com/netology-code/cppm-homeworks/blob/main/common/instr2/readme.md#3-%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F)

# 1. Ошибки и поиск ошибок
Ошибки можно разделить на 2 группы:
1. Ошибки времени компиляции
2. Ошибки времени выполнения

### Ошибки времени компиляции
Это синтаксические ошибки, которые препятствуют сборке программы. Мы не раз с ними сталкивались — например, если забыли где-то поставить `;` (точку с запятой) в конце строки или `{ }` (открывающую/закрывающую) скобку. Синтаксические ошибки легко найти — программа не сможет собраться, а компилятор укажет, в чём ошибка.

### Ошибки времени выполнения
Возникают в ходе работы программы. Например, если вы пытаетесь поделить на ноль, обратиться к элементу массива по индексу, выходящему за его пределы, открыть несуществующий файл, выделить памяти больше, чем доступно. При таких ошибках программа сама завершится из-за невозможности продолжать свою работу.

Бывают и другие ошибки — они связаны с тем, как должна работать программа по задумке программиста. Например, в программе «Калькулятор» вы можете вместо перемножения чисел складывать их. Программа от этого не сломается, но результат будет не тот, что задумывался изначально. Такие ошибки отловить сложнее всего — для этого существует тестирование. В этой статье мы не будем рассматривать подобные ошибки.

## Способы поиска ошибок: отладка и логирование

Представим, что мы запускаем написанную нами программу «Калькулятор», а она в какой-то момент прекращает работу.

Чтобы найти ошибку, нам нужно проследить, как работает наш код. Для этого мы можем:
- Войти в режим отладки и последовательно её выполнить.
- Заставить программу сообщать нам о том, на каком этапе выполнения она находится. Это называется логирование.

### Преимущества и недостатки отладки

Отладка — это процесс обнаружения, анализа и исправления ошибок в программном коде. Отладчики позволяют шаг за шагом выполнять код, просматривать и изменять значения переменных, останавливать выполнение программы при определённых условиях и таким образом локализовать и устранить проблемы. 

Отладка подходит для поиска ошибок в процессе разработки программы.

Плюсы:
- не нужно изменять исходный код
- наглядно: можно посмотреть состояние любой переменной, какая функция вызывает другую функцию, видеть стек вызовов

Минусы:
- требует доступа к исходному коду
- требует наличия отладчика и возможности его запуска

  
Что касается запуска отладчика, это не всегда возможно.
Например, десктопный Яндекс браузер работает на Windows 7 в том числе. А большинство разработчиков пользуются современными быстрыми ОС. И, когда случается специфичный баг на Windows 7, его нужно как-то отладить. Для этих целей используется старый ноутбук со специально установленной Windows 7. Но на нём трудно скомпилировать, запустить браузер и пользоваться отладкой. Приходится с современной машины подключаться к старому ноутбуку, выполнять действия на Windows 7, а отлаживать браузер на новой ОС.


- если программа большая, то поиск может затянуться 

### Преимущества и недостатки логирования

Логирование — это процесс записи информации о работе программы или системы в файлы журналов (лог-файлы). Эти записи могут включать данные о событиях, которые произошли во время выполнения программы, сообщения об ошибках, информацию о транзакциях, статистику работы и другие данные, которые могут быть полезны при анализе и отладке программ. Логирование помогает разработчикам понять, что произошло в приложении после его запуска, и часто является ключевым элементом для выявления и устранения проблем, а также для мониторинга состояния системы в реальном времени.

Логирование используется, когда программа уже готова, и начинают приходить ошибки от пользователей.

Плюсы:
- не требуется доступа к исходному коду, работает вместе с программой
- все этапы выполнения программы доступны сразу, их надо только проанализировать

Минусы:
- логирование требует дополнительного кода в программе

Чтобы в программе были логи, нужно понять, где их написать. Вы не сможете это сделать на любую возможную проблему. Если будет слишком много логов, программа начнёт тормозить, или у пользователя внезапно закончится свободное место на диске.

- при маленьких объёмах кода время, потраченное на логирование, может быть больше, чем вся возможная отладка

## Что делать с найденной ошибкой

Предположим, мы обнаружили, что наша программа «Калькулятор» падает, если мы пытаемся вторым аргументом в функцию `divide` передать число 0.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/c09f1d29-b150-4025-8f6b-648890d06b88)

Как исправить такой код?

### Способ 1. 
Можем попробовать сделать проверку в функции divide перед выполнением операции деления.

Добавим `if (b == 0)`. Далее нам нужно что-то вернуть в `return`. Если напишем какое-то число, это будет работать, но мы не сможем отличить ошибочный результат от реального.

Например, напишем: `return 1`. В случае, если `int a = 10`, а `int b = 10`, и реальный и ошибочный результат будут одинаковыми.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/3c05b176-251d-486e-8bd0-0db14ae55ff3)

### Способ 2. 
Можем попробовать сделать проверку в функции main перед вызовом функции divide.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/15d0fe9f-298a-4b22-b16e-d306bcef11aa)

Так программа будет работать. Но это плохое решение. Получается, что внешний код должен заботиться о том, как работает функция: какие параметры можно передавать, а какие нельзя. Логика получается размазанной: часть логики во внешнем коде, часть внутри функции. 

К тому же, если функция main будет проверять аргументы всех вызываемых ею функций, то код функции main станет очень большим и несфокусированным. Это нарушает принцип инкапсуляции.

Таким образом, оба рассмотренных способа не подходят для решения проблемы. 

Её возможно решить следующими действиями:
- вернуть код возврата
- выбросить исключения

# 2. Коды возврата

Коды возврата — это способ сообщения о произошедшей ошибке, который использовался ещё в языке C. Идея в том, что функция вместо результата, который она должна посчитать, возвращает специальный код, который сообщает о том, правильно отработала функция или нет. Обычно в качестве кодов возврата используются целые числа.

Допустим, мы вернём код возврата. Но как тогда получить результат функции?

Для того, чтобы вернуть результат, в функцию передаётся ещё один аргумент — указатель на переменную, в которую будет помещён результат функции. Вместо указателя может выступать переменная, переданная по ссылке. 

Обычно делают так: код 0 (ноль) означает, что функция отработала корректно. Коды больше 0 означают ошибку. 

Давайте вернём код 1, если знаменатель равен 0 и функция не может произвести деление. В функции main обработаем код возврата.

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/c8cc18d7-77ee-47cf-9e2e-03c9c853b26b)

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/4af0cb49-63aa-47de-90d5-452ad27da5e3)


Если мы поменяем знаменатель на положительное число, например, `int b = 5`, получим результат деления:

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/e9c5855d-2261-4a80-96db-6e9c3f99a3ee)


![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/0c6ea7e5-3779-4203-8ddc-958859d53f10)

Теперь, когда мы изменили нашу функцию divide, появилось новое место для потенциальной ошибки. Нам могут в качестве аргумента quotient прислать нулевой указатель (nullptr). Это указатель, который не указывает ни на какой участок памяти. Адрес, хранящийся в нём, равен нулю. Если мы попытаемся записать значение по такому указателю, мы получим ошибку и наша программа аварийно завершится. 

Давайте добавим ещё одну проверку: если указатель нулевой, вернём код 2, а в функции main выведем сообщение пользователю.


![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/f06c4bcc-2a10-4e56-8f99-64bccb167b6d)


![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/3ca2195a-4f8c-499c-93d4-eee0b47be97b)


Лучше использовать указатель, а не ссылку по нескольким причинам:
- У вас может быть какой-то очень тяжёлый объект. Например, `result` — это большой класс, который долго конструируется. Если у вас будет ссылка, то придётся его сконструировать и передать в функцию ссылку, чтобы просто переписать этот класс.
- В C++ не все типы можно сконструировать. Например, у класса может не быть конструктора по умолчанию.

## Как можно улучшить код возврата

Теперь представим, что вы вызвали функцию чтения из файла, а она вам вернула код возврата в виде какого-то числа.

Но что оно значит? Что файла не существует? Или что он существует, но к нему нет доступа? Или доступ есть, но вы открываете его в неправильном режиме? Или всё хорошо, но не хватает оперативной памяти? 

Очевидно, что просто число — это совершенно не информативно. Хорошо, если документация есть и её можно прочитать, но ещё лучше — если код документирует сам себя. Это идеал, к которому нужно стремиться.

Чтобы коды возврата стали более понятными и удобными, можно использовать перечисление (enum).

Перечисление — это определяемый пользователем тип данных, состоящий из набора именованных целочисленных констант. Объявление перечисления происходит с помощью оператора enum.

Определим перечисление:

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/69163a39-24c2-4415-a567-84327bc527d5)

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/0a09a58e-2597-4550-9f14-2e58cf709a47)

Таким образом, использование перечисления (enum) упрощает понимание и обработку возвращаемых значений, поскольку они имеют осмысленные имена вместо чисел.

### Ещё один способ вернуть код ошибки

Можно попробовать записать результат работы функции в глобальную переменную. Далее после вызова функции пользователь должен проверить эту переменную. Если в ней ошибки нет, то можно использовать результат работы функции.

Этот способ плох по двум причинам:
- Во-первых, он предполагает использование глобальной переменной, что само по себе плохо. Контролировать доступ к глобальной переменной сложно, кто угодно может её поменять. Но этот момент при желании можно обойти.
- Во-вторых, пользователю функции совершенно не очевидно, что где-то есть переменная с каким-то специальным именем, в которой хранится результат функции. Он может (и будет) её просто игнорировать.

Тем не менее, в API операционных системах этот способ активно используется. Например, можно встретить переменную errno при работе с сокетами.

Код возврата тоже не является идеальным решением — ведь пользователь функции может проигнорировать и его, но это уже труднее сделать. 


Тем не менее, использование кода возврата является наилучшим решением с точки зрения производительности. Однако это имеет недостатки с точки зрения безопасности и удобства.

Если вам нужно будет добавить коды возврата в программу, используйте enum class.

# 3. Исключения

Исключения (англ. exceptions) — это специальный набор инструментов для создания, нахождения и обработки ошибок.

Исключения — это специальные значения, которые «выбрасываются» кодом при попытке выполнить какое-то неправильное действие, например, деление на ноль. Выброшенное исключение содержит в себе информацию о произошедшей ошибке и проходит по стеку вызовов наверх до тех пор, пока его кто-то не обработает. Если исключение никто не обработал, то программа аварийно завершается.

То есть, в момент «выброса» исключения, функция, которая была вызвана, прекращает выполнение. После чего исключение попадает в следующую функцию. Если в этой функции никто не обработал исключение, оно поднимается ещё выше. И так продолжается, пока оно не дойдёт до функции main. Если внутри main исключение остаётся необработанным, тогда его поймает операционная система и аварийно завершит программу.

## Синтаксис

Для «выбрасывания» исключения используется ключевое слово `throw` (бросить)

`throw <исключение>;` 

`<исключение>` может быть значением любого типа: число, строка и т.д. Тем не менее, в C++ создан специальный тип для исключений - `std::exception`.

Этот класс символизирует общее исключение и объявляет публичный виртуальный метод `char* what()`, вызвав который, можно получить текстовое описание ошибки. От этого класса наследуются более конкретные стандартные исключения, и вы можете создать свой класс исключения. Рекомендуется пользоваться `std::exception` и его наследниками. Также у `std::exception` есть конструктор, принимающий строку — для описания ошибки. Вызов оператора `throw` прерывает работу программы и возвращает его наверх по стеку вызовов в ожидании обработки.

## Как обработать ошибку

Не любой код может обработать выброшенное исключение. Для этого код должен «ждать» его с помощью оператора `try` (попробовать). Если такой код дождался исключения, то обработка его производится с помощью оператора `catch` (поймать). 

1 блок:

`try`

`{`

`<код, который потенциально может выбросить исключение>`

`}`

2 блок:

`catch(<тип исключения, которое хотим поймать>)`

`{`

`<код, обрабатывающий исключение>`

`}`

Хорошей практикой является «бросать» исключения по значению, а «ловить» — по ссылке.

Параметром для `catch` выступает объявление исключения — почти как аргумент в функции, но имя необязательно. Здесь мы должны указать тип исключения, которое ждём. Можем написать сразу несколько блоков `catch`, чтобы обрабатывать исключения разных типов. Но надо помнить о том, что компилятор пытается привести выброшенное исключение к типу каждого блока `catch` сверху вниз. А это значит, что исключения более общего типа надо писать ниже, чем исключения более конкретного.

Наконец, чтобы обработать исключение любого типа, надо написать … (троеточие). Такой блок всегда должен идти последним, потому что является наиболее общим.
 
`try { <код, который может выбросить исключение> }`

`catch(<тип_1> [<имя_1>]) { <код, обрабатывающий исключение типа тип_1, самый специализированный тип> }`

`catch(<тип_2> [<имя_2>]) { <код, обрабатывающий исключение типа тип_2, менее специализированный тип или просто другой тип> }`

`… catch(...)`

`{ <код, обрабатывающий любое исключение> }`

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/58e9712c-535e-47f6-8958-a78c26078b74)

![image](https://github.com/netology-code/cppm-homeworks/assets/147130852/8713ea32-63da-4877-8389-f89e7b83d1fd)


## Стандартные исключения

В C++ уже существуют классы исключений для разных случаев. 

Вот некоторые из них:
- logic_error — для логических ошибок предметной области
- invalid_argument — неприемлемое значение аргумента
- domain_error — для разных ошибок предметной области
- length_error — попытка превысить какую-либо длину
- out_of_range — попытка получить доступ к элементу за пределами
- bad_cast — неудачная попытка применить dynamic_cast
- bad_alloc — неудачная попытка получить память из кучи
- bad_array_new_length (C++ 11) — неправильная длина при создании динамического массива
- runtime_error — для внешних труднопредсказуемых ошибок
- overflow_error — ошибка переполнения типа
- system_error — для ошибок взаимодействия с ОС
- ios_base::failure (C++ 11) — ошибки библиотеки Input/Output
- filesystem::filesystem_error (C++ 17) — ошибки библиотеки filesystem

Многие алгоритмы и контейнеры стандартной библиотеки `stl` имеют в своем составе механизм проверки ошибок, основанный на выбрасывании исключений. Например, для контейнера `std::vector` определен метод доступа к элементу `reference at(size_type pos)`. Данный метод не просто дает доступ к элементу с номером `pos`, а предварительно проверяет, не выходит ли значение `pos` за пределы массива. Если всё в порядке, то отдается ссылка на элемент с номерм `pos`. Если значение `pos` больше, чем размер массива, то выкидывается исключение типа `std::out_of_range`.

Исключения это не просто способ поиска своих ошибок, а механизм плотно встроенный в стандартные средства C++, который нужно четко знать и понимать.

## Преимущества и недостатки исключений

У механизма исключений есть несколько преимуществ:

- Очевидно, где в коде возникает ошибка (throw) и где она обрабатывается (catch). Эти блоки чётко разделены.
- Выброшенное исключение может быть обработано на разных уровнях вызова — в зависимости от типа исключения. Промежуточные функции, не обладающие компетенциями для обработки исключения, могут пропустить его дальше наверх.
- Исключение заставляет программиста отреагировать на ошибку — обработать исключение либо аварийно завершить работу программы. Игнорировать не удастся.
- При использовании исключений не возникает неопределённого поведения программы. Если мы не проверим код возврата и начнём использовать переменную, в которой лежит какой-то мусор, то может возникнуть неопределённое поведение. Операционная система завершит программу аварийно, и вам будет сложнее понять, что случилось. В случае с исключениями, операционная система поймает исключение и напишет понятный текст, что пошло не так.
- Исключение — единственный способ остановить конструирование объекта до его завершения. Это полезно, если конструктору были переданы неправильные аргументы.

Недостатком исключений является производительность — она меньше, чем у кодов возврата. Компилятор вынужден отказываться от некоторых оптимизаций, чтобы поддерживать механизм исключений. 

## Зачем использовать все рассмотренные способы обработки ошибок?

Казалось бы, зачем усложнять, если при обнаружении ошибки можно просто напечатать сообщение на экран?

Но это плохой способ, потому что:
- В большой программе может быть множество ошибок, и мы должны уметь их обрабатывать. Для пользователя всё это должно выглядеть бесшовно, он не должен знать, что под капотом случаются какие-то ошибки.
- Потом вы можете осознать необходимость не выводить ошибки на экран, а печатать их в файл, так как с ним удобнее работать. И тогда вам придётся бегать по всему своему коду и менять «вывод на консоль» на «вывод в файл».
- Остаётся проблема возврата какого-то значения из функции. Исключения решают эту проблему, прерывая выполнение заведомо ошибочных операций. Печатание на экран не решает проблему выполнения каких-то особенных действий в случае ошибки.

## Заключение

В этом лонгриде мы:
- разобрались, какие бывают ошибки
- познакомились с методами поиска, предотвращения и обработки ошибок
- узнали, что такое коды возврата
- выяснили, что такое исключения

